# CPU and I/O Bursts in Program Execution


## CPU burst
CPU만 사용하면서 연속적으로 명령을 실행하는 단계

## I/O burst
사람과 소통을 해야하는 I/O를 실행하는 단계

***** 프로그램의 실행은 CPU Burst 와 I/O Burst 의 반복으로 이루어진다.**

프로그램의 종류에 따라 각 Burst의 빈도와 길이가 다르기는 하다.

Ex_ 유전체 분석프로그램, 사람과 소통하는 프로그램 등

# CPU-burst Time의 분포
Untitled

## I/O bound job (= I/O bound process)
CPU를 가지고 계산하는 시간보다, I/O에 많은 시간이 필요한 작업 (= 시간이 오래걸림)

## CPU bound job (= CPU bound process)
CPU를 오래 가지고 계산을 하는 작업

효율성을 위해서는 CPU 스케줄링을 통해서 사용자와 직접 소통하는 작업(= I/O bound job)과 CPU bound job을 적절하게 섞어서 사용할 수 있게 해야한다.

# CPU Scheduler & Dispatcher
## CPU Scheduler
Ready 상태의 프로세스 중세서 이번에 CPU를 줄 프로세스를 고른다.

CPU 스케줄링이 필요한 경우, 프로세스의 상태변화

Running → Blocked (ex_ I/O를 요청하는 시스템 콜)
Running → Ready (ex_ 할당시간 만료로 인한 timer interrupt)
Blocked → Ready (ex_ I/O 완료 후 인터럽트)
Terminate
1, 4에서의 스케줄링은 강제로 빼앗지 않고 자진반납하는 nonpreemptive (비선점형) 스케줄링이라고 한다.

(오래걸리는 작업을 하는 1번, 프로그램이 종료된 4번)

다른 모든 스케줄링은 강제로 빼앗는 preemptive (선점형) 스케줄링이다.

## Dispatcher
CPU의 제어권을 CPU scheduler에 의해 선택된 프로세스에게 넘긴다.
⇒ 이 과정을 문맥교환이라고 한다.)

## Scheduling Criteria (스케줄링의 성능척도)
스케줄링의 효율성을 측정할 수 있는 척도
### 시스템 입장
**CPU utilization (이용률)**

전체 시간 중에서 CPU가 일을 진행한 비율
(ex_ 주방장이 전체 업무 시간동안 일을 한 비율)

**Throughput (처리량)**

주어진 시간동안 CPU가 몇개의 일을 진행했는지
(ex_ 시간당 몇명의 손님이 밥을 먹고 나갔는가)

### 프로세스(=고객) 입장
**Turnaround time (소요 시간, 반환 시간)**

프로세스가 CPU를 가지고 다 쓸 때 까지 소요한 시간
- 프로세스가 Ready 큐에 있다가
-  CPU를 쓰러 들어온 후 
- CPU를 다 쓰고 I/O를 하러 나갈 때 까지의 시간
(ex_ 손님이 중국집에 들어와서 주문을 하고 밥을 먹고 나갈 때 까지 걸린 시간)

**Waiting time (대기 시간)**

프로세스가 CPU가 Ready 큐에 줄서서 기다린 시간
(ex_ 손님이 기다린 시간 [음식 주문 등])

**Response time (응답 시간)**

프로세스가 CPU를 가지기까지 걸린 시간
(ex_ 음식이 나오기 까지 걸린 시간)
